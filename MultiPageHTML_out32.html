<!DOCTYPE html><!--[if IE]>  <html class="stl_ie"> <![endif]-->
<html>
	<head>
		<meta charset="utf-8" />
		<title>
		</title>
		<link rel="stylesheet" type="text/css" href="MultiPageHTML_out_files/style.css" />
	</head>
	<body>
		<div class="stl_ stl_02">
			<div class="stl_03">
				<object data="MultiPageHTML_out_files/img_37.svg" type="image/svg+xml" class="stl_04" style="position:absolute; width:42em; height:55.0833em;">
					<embed src="MultiPageHTML_out_files/img_37.svg" type="image/svg+xml" />
				</object>
			</div>
			<div class="stl_view">
				<div class="stl_05 stl_06">
					<div class="stl_01" style="left:5.9998em;top:4.3166em;"><span class="stl_154 stl_32 stl_88" style="word-spacing:0.128em;">Each transaction will execute its first query and update a row of data, locking that &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:5.3666em;"><span class="stl_154 stl_32 stl_117" style="word-spacing:0.0183em;">row in the primary key index and any additional unique index it is part of in the pro‐ &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:6.4166em;"><span class="stl_154 stl_32 stl_123" style="word-spacing:0.0052em;">cess. Each transaction will then attempt to update its second row, only to find that it is &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:7.4666em;"><span class="stl_154 stl_32 stl_158" style="word-spacing:0.1824em;">already locked. The two transactions will wait forever for each other to complete &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:8.5166em;z-index:499;"><span class="stl_154 stl_32 stl_126" style="word-spacing:0.1382em;">unless something intervenes to break the deadlock. </span><span class="stl_154 stl_32 stl_52">W</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1387em;">e </span><span class="stl_154 stl_32 stl_28">c</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1387em;">over further in </span><a href="MultiPageHTML_out177.html#177_0"><span class="stl_184 stl_32 stl_99" style="word-spacing:0.1451em;">Chapter 7 &nbsp;</span></a></div>
					<div class="stl_01" style="left:5.9996em;top:9.5666em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1309em;">how indexing can make or break the performance of your queries as your schema &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:10.6166em;"><span class="stl_154 stl_32 stl_28">evolves. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:12.1666em;"><span class="stl_154 stl_32 stl_105" style="word-spacing:0.4243em;">To </span><span class="stl_154 stl_32 stl_28">c</span><span class="stl_154 stl_32 stl_35" style="word-spacing:0.2311em;">ombat this problem, database systems implement various forms of deadlock &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:13.2166em;"><span class="stl_154 stl_32 stl_158" style="word-spacing:0.0389em;">detection and timeouts. The more sophisticated systems, such as the InnoDB storage &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:14.2666em;"><span class="stl_154 stl_32 stl_77" style="word-spacing:0.056em;">engine, will notice circular dependencies and return an error instantly. This can be a &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:15.3166em;"><span class="stl_154 stl_32 stl_185" style="word-spacing:0.1333em;">good thing—otherwise, deadlocks would manifest themselves as very slow queries. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:16.3666em;"><span class="stl_154 stl_32 stl_37" style="word-spacing:0.0815em;">Others will give up after the query exceeds a lock wait timeout, which is not always &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:17.4166em;"><span class="stl_154 stl_32 stl_78" style="word-spacing:0.1424em;">good. The way InnoDB currently handles deadlocks is to roll back the transaction &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:18.4666em;"><span class="stl_154 stl_32 stl_73" style="word-spacing:0.0676em;">that has the fewest exclusive row locks (an approximate metric for which will be the &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:19.5166em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">easiest to roll back). &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:21.0666em;"><span class="stl_154 stl_32 stl_53" style="word-spacing:0.0887em;">Lock behavior and order are storage engine specific, so some storage engines might &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:22.1166em;"><span class="stl_154 stl_32 stl_24" style="word-spacing:0.1304em;">deadlock on a certain sequence of statements even though others won’t. Deadlocks &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:23.1666em;"><span class="stl_154 stl_32 stl_39" style="word-spacing:0.0233em;">have a dual nature: some are unavoidable because of true data conflicts, and some are &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:24.2166em;"><span class="stl_154 stl_32 stl_74" style="word-spacing:0.0016em;">caused by how a storage engine works.</span><sup style="top: -0.2917em;"><a href="MultiPageHTML_out32.html#32_1"><span class="stl_166 stl_32 stl_35" style="word-spacing:0.0027em;">7 &nbsp;</span></a></sup></div>
					<div class="stl_01" style="left:6.0002em;top:25.7666em;"><span class="stl_154 stl_32 stl_57" style="word-spacing:0.0056em;">Once they occur, deadlocks cannot be broken without rolling back one of the transac‐ &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:26.8166em;"><span class="stl_154 stl_32 stl_83" style="word-spacing:0.1035em;">tions, either partially or wholly. They are a fact of life in transactional systems, and &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:27.8666em;"><span class="stl_154 stl_32 stl_84" style="word-spacing:0.0792em;">your applications should be designed to handle them. Many applications can simply &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:28.9166em;"><span class="stl_154 stl_32 stl_37" style="word-spacing:0.0274em;">retry their transactions from the beginning, and unless they encounter another dead‐ &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:29.9666em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">lock, they should be successful. &nbsp;</span></div>
					<div class="stl_01" style="left:5.9994em;top:31.8509em;"><span class="stl_180 stl_27 stl_28" style="word-spacing:0em;">Transaction Logging &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:33.7507em;"><span class="stl_154 stl_32 stl_54" style="word-spacing:0.0953em;">Transaction logging helps make transactions more efficient. Instead of updating the &nbsp;</span></div>
					<div class="stl_01" style="left:6.0002em;top:34.8007em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.2246em;">tables on disk each time a change occurs, the storage engine can change its in- &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:35.8507em;"><span class="stl_154 stl_32 stl_188" style="word-spacing:-0.0015em;">memory copy of the data. This is very fast. The storage engine can then write a record &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:36.9007em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.0827em;">of the change to the transaction log, which is on disk and therefore durable. This is &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:37.9507em;"><span class="stl_154 stl_32 stl_72" style="word-spacing:0.0758em;">also a relatively fast operation, because appending log events involves sequential I/O &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:39.0007em;"><span class="stl_154 stl_32 stl_95" style="word-spacing:0.1013em;">in one small area of the disk instead of random I/O in many places. Then, at some &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:40.0507em;"><span class="stl_154 stl_32 stl_35" style="word-spacing:0.0212em;">later time, a process can update the table on disk. Thus, most storage engines that use &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:41.0893em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1611em;">this technique (known as </span><span class="stl_155 stl_41 stl_38" style="word-spacing:0.1658em;">write-ahead logging</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1611em;">) end up writing the changes to disk &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:42.1507em;"><span class="stl_154 stl_32 stl_28">twice. &nbsp;</span></div>
					<div class="stl_01" style="left:6.095em;top:47.4369em;"><span class="stl_167 stl_32 stl_28">7</span></div>
					<div class="stl_01" style="left:6.6667em;top:47.3545em;"><span class="stl_168 stl_32 stl_72" style="word-spacing:0.0043em;">As you will see later in this chapter, some storage engines lock entire tables, and others implement more com‐ &nbsp;</span></div>
					<div class="stl_01" style="left:6.6667em;top:48.1878em;z-index:171;"><span class="stl_168 stl_32 stl_39" style="word-spacing:0.0033em;">plex row-based locking. All that logic lives for the most part in the storage engine layer. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:50.8098em;"><span class="stl_80 stl_27 stl_28">10 &nbsp;</span></div>
					<div class="stl_01" style="left:7.3623em;top:50.8098em;"><span class="stl_80 stl_27 stl_28">|</span></div>
					<div class="stl_01" style="left:8.2698em;top:50.8098em;"><span class="stl_80 stl_27 stl_28" style="word-spacing:0em;">Chapter 1: MySQL Architecture &nbsp;</span></div>
					<a name="32_0" style="position:absolute;left:0em;top:32.144em;">&nbsp;</a>
					<a name="32_1" style="position:absolute;left:0em;top:47.4458em;">&nbsp;</a>
					<a name="32_2" style="position:absolute;left:0em;top:13.4458em;">&nbsp;</a>
					<a name="32_3" style="position:absolute;left:0em;top:17.6458em;">&nbsp;</a>
					<a name="32_4" style="position:absolute;left:0em;top:33.9799em;">&nbsp;</a>
				</div>
			</div>
		</div>
	</body>
</html>