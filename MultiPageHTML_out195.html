<!DOCTYPE html><!--[if IE]>  <html class="stl_ie"> <![endif]-->
<html>
	<head>
		<meta charset="utf-8" />
		<title>
		</title>
		<link rel="stylesheet" type="text/css" href="MultiPageHTML_out_files/style.css" />
	</head>
	<body>
		<div class="stl_ stl_02">
			<div class="stl_03">
				<object data="MultiPageHTML_out_files/img_205.svg" type="image/svg+xml" class="stl_04" style="position:absolute; width:42em; height:55.0833em;">
					<embed src="MultiPageHTML_out_files/img_205.svg" type="image/svg+xml" />
				</object>
			</div>
			<div class="stl_view">
				<div class="stl_05 stl_06">
					<div class="stl_01" style="left:6.0001em;top:4.3166em;"><span class="stl_154 stl_32 stl_158" style="word-spacing:0.0006em;">navigations instead of one.</span><sup style="top: -0.2917em;"><a href="MultiPageHTML_out195.html#195_0"><span class="stl_166 stl_32 stl_28" style="word-spacing:0.1877em;">7 </span></a></sup><span class="stl_154 stl_32 stl_35" style="word-spacing:0.0131em;">In InnoDB, the adaptive hash index (mentioned earlier in &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:5.3666em;z-index:385;"><a href="MultiPageHTML_out179.html#179_2"><span class="stl_184 stl_32 stl_54" style="word-spacing:0.0041em;">“B-tree indexes” on page 157</span></a><span class="stl_154 stl_32 stl_43" style="word-spacing:0.0073em;">) can help reduce this penalty. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:7.4235em;"><span class="stl_193 stl_27 stl_28" style="word-spacing:0em;">InnoDB’s data layout &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:8.8909em;z-index:443;"><span class="stl_154 stl_32 stl_105" style="word-spacing:0.2921em;">To </span><span class="stl_154 stl_32 stl_28">b</span><span class="stl_154 stl_32 stl_95" style="word-spacing:0.0978em;">etter understand clustered indexes, let</span><span class="stl_154 stl_32 stl_34">’</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.0961em;">s </span><span class="stl_154 stl_32 stl_28">s</span><span class="stl_154 stl_32 stl_74" style="word-spacing:0.0976em;">ee how InnoDB lays out the following &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:9.9409em;"><span class="stl_154 stl_32 stl_28">table: &nbsp;</span></div>
					<div class="stl_01" style="left:7.4166em;top:11.7035em;"><span class="stl_200 stl_171 stl_28">CREATE TABLE layout_test ( &nbsp;</span></div>
					<div class="stl_01" style="left:7.7708em;top:12.5535em;"><span class="stl_200 stl_171 stl_28" style="word-spacing:0em;">col1 int NOT NULL, &nbsp;</span></div>
					<div class="stl_01" style="left:7.7708em;top:13.4035em;"><span class="stl_200 stl_171 stl_28" style="word-spacing:0em;">col2 int NOT NULL, &nbsp;</span></div>
					<div class="stl_01" style="left:7.7708em;top:14.2535em;"><span class="stl_200 stl_171 stl_28">PRIMARY KEY(col1), &nbsp;</span></div>
					<div class="stl_01" style="left:7.7708em;top:15.1035em;"><span class="stl_200 stl_171 stl_28">KEY(col2) &nbsp;</span></div>
					<div class="stl_01" style="left:7.4166em;top:15.9535em;"><span class="stl_200 stl_171 stl_28">); &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:17.0909em;"><span class="stl_154 stl_32 stl_37" style="word-spacing:0.0753em;">Suppose the table is populated with primary key values 1 to 10,000, inserted in ran‐ &nbsp;</span></div>
					<div class="stl_01" style="left:6.0002em;top:18.1904em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1641em;">dom order and then optimized with </span><span class="stl_170 stl_171 stl_28" style="word-spacing:0.1641em;">OPTIMIZE TABLE</span><span class="stl_154 stl_32 stl_83" style="word-spacing:0.1664em;">. In other words, the data is &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:19.2404em;"><span class="stl_154 stl_32 stl_77" style="word-spacing:0.0432em;">arranged optimally on disk, but the rows might be in a random order. The values for &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:20.3398em;"><span class="stl_170 stl_171 stl_28">col</span><span class="stl_170 stl_171 stl_186">2</span><span class="stl_154 stl_32 stl_140" style="word-spacing:0.0008em;">are randomly assigned between 1 and 100, so there are lots of duplicates. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:21.8898em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">InnoDB stores the table as shown in </span><a href="MultiPageHTML_out195.html#195_1"><span class="stl_184 stl_32 stl_28" style="word-spacing:0em;">Figure 7-4</span></a><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:35.8337em;"><span class="stl_155 stl_41 stl_192" style="word-spacing:0.0157em;">Figure 7-4. InnoDB primary key layout for the </span><span class="stl_174 stl_175 stl_28">layout_tes</span><span class="stl_174 stl_175 stl_259">t</span><span class="stl_155 stl_41 stl_22">table &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:37.8951em;"><span class="stl_154 stl_32 stl_37" style="word-spacing:0.0432em;">Each leaf node in the clustered index contains the primary key value, the transaction &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:38.9451em;"><span class="stl_154 stl_32 stl_73" style="word-spacing:0.0365em;">ID and rollback pointer InnoDB uses for transactional and MVCC purposes, and the &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:40.0445em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1447em;">rest of the columns (in this case, </span><span class="stl_170 stl_171 stl_28">col2</span><span class="stl_154 stl_32 stl_141" style="word-spacing:0.1424em;">). If the primary key is on a column prefix, &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:41.0945em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">InnoDB includes the full column value with the rest of the columns. &nbsp;</span></div>
					<div class="stl_01" style="left:6.095em;top:46.6036em;"><span class="stl_167 stl_32 stl_28">7</span></div>
					<div class="stl_01" style="left:6.6667em;top:46.5212em;"><span class="stl_168 stl_32 stl_43" style="word-spacing:0.0073em;">Nonclustered index designs aren’t always able to provide single-operation row lookups, by the way. When a &nbsp;</span></div>
					<div class="stl_01" style="left:6.6667em;top:47.3545em;"><span class="stl_168 stl_32 stl_97" style="word-spacing:0.0029em;">row changes, it might not fit in its original location anymore, so you might end up with fragmented rows or &nbsp;</span></div>
					<div class="stl_01" style="left:6.6667em;top:48.1878em;z-index:262;"><span class="stl_168 stl_32 stl_36" style="word-spacing:0.0039em;">“forwarding addresses” in the table, both of which would result in more work to find the row. &nbsp;</span></div>
					<div class="stl_01" style="left:23.2085em;top:50.8098em;"><span class="stl_80 stl_27 stl_28" style="word-spacing:0em;">Indexing Strategies for High Performance &nbsp;</span></div>
					<div class="stl_01" style="left:34.1743em;top:50.8098em;"><span class="stl_80 stl_27 stl_28">|</span></div>
					<div class="stl_01" style="left:35.0818em;top:50.8098em;"><span class="stl_80 stl_27 stl_28">173 &nbsp;</span></div>
					<a name="195_0" style="position:absolute;left:0em;top:46.6125em;">&nbsp;</a>
					<a name="195_1" style="position:absolute;left:0em;top:23.5815em;">&nbsp;</a>
					<a name="195_2" style="position:absolute;left:0em;top:9.1202em;">&nbsp;</a>
				</div>
			</div>
		</div>
	</body>
</html>