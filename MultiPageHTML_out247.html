<!DOCTYPE html><!--[if IE]>  <html class="stl_ie"> <![endif]-->
<html>
	<head>
		<meta charset="utf-8" />
		<title>
		</title>
		<link rel="stylesheet" type="text/css" href="MultiPageHTML_out_files/style.css" />
	</head>
	<body>
		<div class="stl_ stl_02">
			<div class="stl_03">
				<object data="MultiPageHTML_out_files/img_263.svg" type="image/svg+xml" class="stl_04" style="position:absolute; width:42em; height:55.0833em;">
					<embed src="MultiPageHTML_out_files/img_263.svg" type="image/svg+xml" />
				</object>
			</div>
			<div class="stl_view">
				<div class="stl_05 stl_06">
					<div class="stl_01" style="left:6em;top:4.3166em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.0824em;">This query returns rentals 16049 through 16030. The next query can continue from &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:5.3666em;"><span class="stl_154 stl_32 stl_85" style="word-spacing:0.0095em;">that point: &nbsp;</span></div>
					<div class="stl_01" style="left:7.4167em;top:7.1285em;"><span class="stl_265 stl_173 stl_28">SELECT * FROM sakila.rental &nbsp;</span></div>
					<div class="stl_01" style="left:7.4167em;top:7.9785em;"><span class="stl_265 stl_173 stl_28">WHERE rental_id &lt; 16030 &nbsp;</span></div>
					<div class="stl_01" style="left:7.4167em;top:8.8285em;"><span class="stl_265 stl_173 stl_28">ORDER BY rental_id DESC LIMIT 20; &nbsp;</span></div>
					<div class="stl_01" style="left:6.0002em;top:9.9666em;z-index:191;"><span class="stl_154 stl_32 stl_97" style="word-spacing:0.1048em;">The nice thing about this technique is that it</span><span class="stl_154 stl_32 stl_34">’</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1017em;">s </span><span class="stl_154 stl_32 stl_28">v</span><span class="stl_154 stl_32 stl_140" style="word-spacing:0.1025em;">ery efficient no matter how far you &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:11.0166em;"><span class="stl_154 stl_32 stl_72" style="word-spacing:0.0045em;">paginate into the table. &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:12.5666em;"><span class="stl_154 stl_32 stl_53" style="word-spacing:0.1133em;">Other alternatives include using precomputed summaries or joining against redun‐ &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:13.6166em;"><span class="stl_154 stl_32 stl_53" style="word-spacing:0.1897em;">dant tables that contain only the primary key and the columns you need for the &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:14.716em;"><span class="stl_170 stl_171 stl_28" style="word-spacing:0em;">ORDER BY</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">. &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:16.6003em;"><span class="stl_180 stl_27 stl_28" style="word-spacing:0em;">Optimizing SQL_CALC_FOUND_ROWS &nbsp;</span></div>
					<div class="stl_01" style="left:6.0002em;top:18.5495em;"><span class="stl_154 stl_32 stl_95" style="word-spacing:0.3911em;">Another common technique for paginated displays is to add the </span><span class="stl_170 stl_171 stl_28" style="word-spacing:-0.111em;">SQL_ CALC_ &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:19.649em;"><span class="stl_170 stl_171 stl_28">FOUND_ROW</span><span class="stl_170 stl_171 stl_385">S</span><span class="stl_154 stl_32 stl_112" style="word-spacing:0.031em;">hint to a query with a </span><span class="stl_170 stl_171 stl_28">LIMIT</span><span class="stl_154 stl_32 stl_54" style="word-spacing:0.0369em;">, so you’ll know how many rows would have &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:20.7484em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1474em;">been returned without the </span><span class="stl_170 stl_171 stl_28">LIMIT</span><span class="stl_154 stl_32 stl_121" style="word-spacing:0.1665em;">. It might seem that there’s some kind of “magic” &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:21.7984em;"><span class="stl_154 stl_32 stl_53" style="word-spacing:0.1281em;">happening here, whereby the server predicts how many rows it would have found. &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:22.8484em;"><span class="stl_154 stl_32 stl_192" style="word-spacing:0.2262em;">But unfortunately, the server doesn’t really do that; it can’t count rows it doesn’t &nbsp;</span></div>
					<div class="stl_01" style="left:6.0001em;top:23.8984em;"><span class="stl_154 stl_32 stl_88" style="word-spacing:0.0703em;">actually find. This option just tells the server to generate and throw away the rest of &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:24.9484em;z-index:887;"><span class="stl_154 stl_32 stl_83" style="word-spacing:0.0652em;">the result set instead of stopping when it reaches the desired number of rows. That</span><span class="stl_154 stl_32 stl_34">’</span><span class="stl_154 stl_32 stl_34">s &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:25.9984em;"><span class="stl_154 stl_32 stl_204" style="word-spacing:-0.0048em;">very expensive. &nbsp;</span></div>
					<div class="stl_01" style="left:5.9996em;top:27.5484em;"><span class="stl_154 stl_32 stl_97" style="word-spacing:0.0399em;">A better design is to convert the pager to a “next” link. Assuming there are 20 results &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:28.6479em;"><span class="stl_154 stl_32 stl_178" style="word-spacing:-0.002em;">per page, the query should then use a </span><span class="stl_170 stl_171 stl_28">LIMI</span><span class="stl_170 stl_171 stl_305">T</span><span class="stl_154 stl_32 stl_74" style="word-spacing:0.0015em;">of 21 rows and display only 20. If the 21st &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:29.6979em;z-index:1069;"><span class="stl_154 stl_32 stl_123" style="word-spacing:0.0053em;">row exists in the results, there</span><span class="stl_154 stl_32 stl_34">’</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">s a </span><span class="stl_154 stl_32 stl_28">n</span><span class="stl_154 stl_32 stl_33" style="word-spacing:0.0041em;">ext page, and you can render the “next” link. &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:31.2479em;"><span class="stl_154 stl_32 stl_33" style="word-spacing:0.0537em;">Another possibility is to fetch and cache many more rows than you need—say, 1,000 &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:32.2979em;"><span class="stl_154 stl_32 stl_117" style="word-spacing:0.0467em;">—and then retrieve them from the cache for successive pages. This strategy lets your &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:33.3479em;z-index:1296;"><span class="stl_154 stl_32 stl_48" style="word-spacing:0.1642em;">application know how large the full result set is. If it</span><span class="stl_154 stl_32 stl_34">’</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1606em;">s </span><span class="stl_154 stl_32 stl_28">f</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1606em;">ewer than 1,000 rows, the &nbsp;</span></div>
					<div class="stl_01" style="left:6.0002em;top:34.3979em;z-index:1365;"><span class="stl_154 stl_32 stl_48" style="word-spacing:0.1331em;">application knows how many page links to render; if it</span><span class="stl_154 stl_32 stl_34">’</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.1295em;">s </span><span class="stl_154 stl_32 stl_28">m</span><span class="stl_154 stl_32 stl_72" style="word-spacing:0.134em;">ore, the application can &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:35.4479em;z-index:1425;"><span class="stl_154 stl_32 stl_77" style="word-spacing:0.0645em;">just display “more than 1,000 results found</span><span class="stl_154 stl_32 stl_161">.</span><span class="stl_154 stl_32 stl_46" style="word-spacing:0.064em;">” Both strategies are much more efficient &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:36.4979em;"><span class="stl_154 stl_32 stl_83" style="word-spacing:0.0023em;">than repeatedly generating an entire result and discarding most of it. &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:38.0479em;"><span class="stl_154 stl_32 stl_140" style="word-spacing:0.1654em;">Sometimes you can also just estimate the full size of the result set by running an &nbsp;</span></div>
					<div class="stl_01" style="left:5.9999em;top:39.1473em;"><span class="stl_170 stl_171 stl_28">EXPLAI</span><span class="stl_170 stl_171 stl_420">N</span><span class="stl_154 stl_32 stl_188" style="word-spacing:0.0086em;">query and looking at the </span><span class="stl_170 stl_171 stl_28">row</span><span class="stl_170 stl_171 stl_420">s</span><span class="stl_154 stl_32 stl_111" style="word-spacing:0.0221em;">column in the result (hey, even Google doesn’t &nbsp;</span></div>
					<div class="stl_01" style="left:5.9998em;top:40.2467em;"><span class="stl_154 stl_32 stl_47" style="word-spacing:0.1305em;">show exact result counts!). If you can’t use these tactics, using a separate </span><span class="stl_170 stl_171 stl_28">COUNT(*) &nbsp;</span></div>
					<div class="stl_01" style="left:6.0004em;top:41.3462em;"><span class="stl_154 stl_32 stl_158" style="word-spacing:0.0073em;">query to find the number of rows can be much faster than </span><span class="stl_170 stl_171 stl_28">SQL_CALC_FOUND_ROWS</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">, if it &nbsp;</span></div>
					<div class="stl_01" style="left:5.9997em;top:42.3962em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0em;">can use a covering index. &nbsp;</span></div>
					<div class="stl_01" style="left:5.9995em;top:44.2805em;"><span class="stl_180 stl_27 stl_28" style="word-spacing:0em;">Optimizing UNION &nbsp;</span></div>
					<div class="stl_01" style="left:6.0003em;top:46.2297em;"><span class="stl_154 stl_32 stl_120" style="word-spacing:0.1713em;">MySQL always executes </span><span class="stl_170 stl_171 stl_28" style="word-spacing:-0.0873em;">UNION </span><span class="stl_154 stl_32 stl_158" style="word-spacing:0.1656em;">queries by creating a temporary table and filling it &nbsp;</span></div>
					<div class="stl_01" style="left:6em;top:47.3291em;"><span class="stl_154 stl_32 stl_28" style="word-spacing:0.0391em;">with the </span><span class="stl_170 stl_171 stl_28">UNIO</span><span class="stl_170 stl_171 stl_425">N</span><span class="stl_154 stl_32 stl_81" style="word-spacing:0.0507em;">results. MySQL can’t apply as many optimizations to </span><span class="stl_170 stl_171 stl_28">UNIO</span><span class="stl_170 stl_171 stl_425">N</span><span class="stl_154 stl_32 stl_28" style="word-spacing:0.0391em;">queries as &nbsp;</span></div>
					<div class="stl_01" style="left:24.6008em;top:50.8098em;"><span class="stl_80 stl_27 stl_28" style="word-spacing:0em;">Optimizing </span><span class="stl_233 stl_27 stl_28" style="word-spacing:-0.092em;">Speciﬁc </span><span class="stl_80 stl_27 stl_28" style="word-spacing:0em;">Types of Queries &nbsp;</span></div>
					<div class="stl_01" style="left:34.1745em;top:50.8098em;"><span class="stl_80 stl_27 stl_28">|</span></div>
					<div class="stl_01" style="left:35.082em;top:50.8098em;"><span class="stl_80 stl_27 stl_28">225 &nbsp;</span></div>
					<a name="247_0" style="position:absolute;left:0em;top:16.8934em;">&nbsp;</a>
					<a name="247_1" style="position:absolute;left:0em;top:44.5736em;">&nbsp;</a>
					<a name="247_2" style="position:absolute;left:0em;top:18.7788em;">&nbsp;</a>
					<a name="247_3" style="position:absolute;left:0em;top:46.4589em;">&nbsp;</a>
				</div>
			</div>
		</div>
	</body>
</html>